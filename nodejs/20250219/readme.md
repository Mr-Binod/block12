

# OSI7 계층, HTTP

> 네트워크 통신을 쉽게 이해할수 있도록 계층을 나눈 개념
> 각 계층이 역활을 가지고 계층간에 데이트를 주고받기 위해서 네트워크 통신을 단계별로 나눈것

> 물데네전세표응

1. 물리 계층   (HARDWARE)
> 두 컴퓨터가 있다고 가정하면
> 컴퓨터는 파일이나 프로그램들이 모두 0 과 1 로 관리한다.
> 두 컴퓨터는 통신을 하기 위해서 전기 신호, 전자 기파 등을 사용해서 데이트를 표현하고 전달해야한다.
> 0101 => 아날로그 신호로 변환해서 ---> 디지털 신호로 바꾼다 (0 과 1 값으로) 복원해서 데이터를 받을수 있다.

> 배달을 한다고 가정하면 물리계층은 도로의 역활

2. 데이터 링크 계층   (HARDWARE)
> 같은 넷워크에 있는 여러 컴퓨터가 데이터를 주고받을 수 있도록 한다.
> 스위치 : 네트워크에 있는 데이터를 전송하는 하드웨어 
> 브리지 : 네트워크 연결해서 데니터의 흐름을 관리한다.
> 램카드 : 컴퓨터와 네트워크를 연결하는 하드웨어
> MAC 주소 : 네트워크의 장치의 고유 주소

> 배달기사가 도로를 통해 배달을 하면서 차선 등 옴겨다니며 신호등을 보고 사고가 안나게 배달을 진행하는것


3. 네트워크 계층  (HARDWARE + SOFTWARE)
> IP 주소를 사용해서 데이트를 목적지 즉 컴퓨터로 전송한다.
> 라우트 : 네트워크에 패킷을 라우팅하는 하드웨어, IP 주소를 기반으로 데이터를 전송한다.
> DNS www.naver.com -> IP 
> IP 주소 : 인터넷에서 정치간의 통신을 위해 사용하는 고유의 주소

> 배달기사가 주고를 보고 목적지까지 배달하는 과정


4. 전송 계층 (SOFTWARE)
> 포트번호를 사용해서 데이트를 받은 컴퓨터에게 최종 목적지 프로세스까지 도달 하도록 한다.
> 운영체제의 커널에 구현되어 있다.
> 3000

5. 세션 계층 (SOFTWARE)
> 세셴은 설정하고 관리하고 유지
> 로그인 유지 동기화

6. 표현 계층 
> 데이터의 인코딩 디코딩해서 압축이나 암호화를 한다
> 데이터 포멧 GIF JPEG 등의 파일 처리 변환
> 암호화 : SSL 등의 보안

7. 응용 계층
> 유저가 직접 인터넷을 이용하는것 상호작용을 하는 계층
> 웹 서비스 : API 통신 이메일 전송 파일 전송


### OSI7 모델과 TCP/IP 모델

> 이전에는 OSI 7계층 모델을 주로 사용했는데
> 현제는 인터냇이 TCP/IP 모델을 더 많이 사용하게 되었다.
> 시장 점유 싸움에서 밀려서 TCP/IP 가 더 우세했다.

### TCP/IP 
> 기존 TCP 모델은 4 계층으로
1. 네트워크 엑세스 계층  : [ `1. 물리 계층, 2. 데이터 링크 계층이 포함 `]
2. 인터넷 계층  : `3. IP 주소 기반의 데이터 전달`
3. 전송 계층  : `4. TCP/UDP 신뢰성이 있는 데이터를 전송`
4. 응용 계층  : HTTP 등의 프로토콜을 제공 `5. 세견 계층, 6. 표현 계층, 7, 응용 계층 포함`


### TCP/IP 업데이트 모델
1. 네트워크 인터페이스 계층 :  물리적 전송 매체 등과 하드웨어 ( 이더넷 WIFI 등 포함)
2. 인터넷 계층 :  IP 주소 기반 패킷 전달 IPv4
3. 전송 계층  : TCP UDP 등을 지원
4. 응용 계층  :  HTTP 웹 소켓 등

### TCP 와 UDP   (PROTOCOL)
> `프로토콜` 네트워크에서 데이터를 전송 즉 요청 응답을 하기위해서 규칙을 정한것
> OSI 모델의 4 계층 전송 계층에 해당한다

### TCP (연결성) (현재 많이 사용하고 있는 모델)
> 데이터 전송 이전 두 장치가 안정적인 논리적 연결을 했는지 검사 하는 프로토콜


### UDP (비연결성) (user datagran protocol)
> 데이터의 전송 논리적 연결을 하지않고 데이터전송을 지향하는 프로토콜
> (영상 스트리밍 게임 등 같은 짧은 대기시간 빠른 속도가 필요한 곳에 사용)


### TCP  (transmission control protocol)
### 3-way-handshake  논리적인 연결 (LOGICAL CONNECTION)
> 클라이언터가 백엔드로 서버로 요청을 보내면 준비를 하는 단계
> 데이트를 주고받기 위해서 안전한 검정이 되면 논리적으로 연결이 되었다.
1. SYN 전송
> 클라이언트가 서버에 준비됬니?
> SYN 패킷을 보낸다

2. SYN-ACK 응답  (SYNCHRONISE AND ACKNOWLEDGE)
> 서버에서 클라이언터에서 나 준비됬어 ㅇㅇ
> 서버에서는 SYN-ACK의 패킷을 보낸다

3. ACK 전송
> 클라이언트가 서버에게 메시지를 받아서 나 잘받았어 우리 이제 데이터를 주고받자
> 논리적 연결이 되는 시점.

## 예시 
> 클라이언트 -> 서버 : SYN 패킷
> 서버 -> 클라이언트 : SYN + ACK
> 클라이언트 -> : ACK
> 논리적 연결이 된 상태 값을 데이터를 안전하게 전송할 준비가 끝났다.

> 데이터를 전송하는 과정이 일어난다.

### 4-way-handshake

> 논리적 연결을 종료될때 일어나는 일

1. FIN 전송
> 클라이언트에서 이제 논리적 연결 종료하자
> 너 데이터 다 보냈니?

2. ACK 응답 
> 서버 나 아직 응답할게 남아있어
> 데이터를 전송하자 못했으면 다 처리

3. FIN 전송
> 서버에서 클라이언트에게 데이터를 다 보냈고 준비됬다

4. ACK 응답
> 서버가 응답을 받고 나 확인한후 완전히 종료


### 한줄 요약 (SUMMERISE)
> 3-way-handshake 는 논리적 연결 시작
> 4-way- handshake 연결 종료
> 우리가 데이터를 네트워크에서 주고받을떄 TCP 연결 지향 방식으로 데이터를


### 바이너리 데이터
> 사람이 숫자를 셀때 세는이유는 손가락이 10 개니까
> 컴퓨터는 전기가 들어왔다 들어오지 않았다.
> 이진수 구하는 공식 2로 나누면서 나머지 값을 모두 정렬하면 이진수로 표현된다.
> 이진수는 자리수가 올라가는때는 1 에서 값이 증가하면 자리수가 증가 2 값마다 자리수가 증가한다.
> 이진수는 0 ~ -> 이후 자리수 증가 1,10,11,100,101

> 1000 이라는 이준수가 있으면 2 진수의 하나의 자리수당 비트 bit
> 4 bit `바이트 패딩` 
> 컴퓨터가 사용하는 단위는 bit, byte, megabyte, kilobyte
> 이 비트가 8 개가 모이면 바이트라는 컴퓨터의 가장 기본 단위가 된다.

### binary data
> 컴퓨터는 기본 0 과 1 을 표현하고
> 우리는 데이터를 표현할때 비트나 바이트라는 단위를 많이 사용한다
> 데니터의 가지수를 표현할때 사용하는 방법 이라고 보시면 됨
> 12 라는 값을 저장해줘 작성하면 1 은 알고 2 는 모르는친구 이진수로 (Binary) 변환 1100 이런식으로 저장
> 숫자 문제 발생 글자는?
> A 라는 글자를 이진수 표현을 어떻게 하지?
> `character set 문자 집합` keycode : 컴퓨터는 A 와 a 가 다르게 받아들인다.
> 영어 문자도 숫자로 표현
> A 는 = 64 , a 는 = 97  을 이진수로 변환해서 저장
> 사람이 정해놨기때문이다 `문자 집합`
> 문자 집합 : 문자를 숫자로 표현할수 있도록 정의한 규칙

### ASCII CODE
> 글자를 표현할때 8bit 만 사용한다. 1 byte 
> 8 bit 중에서 1bit 는 오류 체크 용도로 실제로 사용은 7bit
> 1 bit 는 오류 체크용으로 사용하고 `parity bit (페리티 비트)`
> 00000000 ~ 11111111 즉 2^7 === 128 까지의 아스키 코드는 128 까지의 글자를 표현할수 있게된것
> 한글을 제외한 키보드의 자판에 있는 영어와 특수문자만 표현이 가능하다
> 한글은 1 byte 로는 표현이 불가능 알파벳은 1 글자 한글은 1 자음으로는 표현할수 없기 때문에

### 유니코드
> 유니코드는 전세개의 문자를 일관되게 표현할수 있도록 설계한 표준
> ASCII 코드와 유니코드의 큰 차이점은 용량의 차이
> 글자는 하나당 1 BYTE 가 아닌 2 BYTE 를 사용한다.

### 16 진수 
> 2 진수와 10 진수
> 문자의 길이가 너무 길어서 2 진수로 표현하면 비효율적 너무 길다. 16 진수로 표현을 하자
> 16 진수를 수하는 식은
> 1 2 3 4 5 6 7 8 9 A B C D E F 자리수 증가   A1 B2
> 10 진수를 16 으로 나누고 나머지를 16 진수로 표현 나눈 몫을 0 이 될때까지 반복
> 30 -> 1E 

### 인코딩의 규칙 
> 문자를 숫자로 나타내는 것의 규칙이 있는 것처럼
> 숫자를 바이너리 데이터로 나타내는 규칙 있다
> A는 숫자 65 -> 이진수로 표현하면 1000001 으로 표현이 된다.
> A12 를 컴퓨터가 2 진수로 표현하면 10000011100 이렇게 변환을 해서 저장한다
> 컴퓨터는 어디서 나눠야할지 어디를 잘라야할지 몊글자를 잘라야하나
> 1000 001100 결과물이 달라질수 있는것
> 앞을 8 bit 씩 4 bit 씩 잘라야 A12 글자를 만들수가 있는데
> 그래서 우리는 이런 값을 `문자 인코딩` 을 하는것
> 문자 인코딩 중 하나인  UTF8 => 8 의 숫자가 바로 BIT를 나타내는것
> 12 라는 숫자는 4 BIT 으로 표현이 가능한데 문자는 인코딩을 통해서 8 bit 로 변환을 해야한다.
> 변환하는 건 어려운데 아니고 단순하게 4 자리의 숫자를 8 자리의 숫자로 표현을 해놓으면 끝
> 0000+1100 자리슈를 0으로 채워주는것 12 => 1000001 00001100 숫자도 문자 인코딩을 통해서 같이 표현이 가능

1. A
> A -> 문자집합 -> 65 -> 1000001 (이진수) -> 01000001(문자 인코딩) 8 bit 으로 저장

2. 12 
> 12 -> 1100(이진수) -> 00001100 (문자 인코딩)

> 반대로 값을 호출하면 디코딩


### 요청 헤더 메세지, 요청과 응답 느낌, 3-way-handshake, 4-way-handshake, GET AND POST

