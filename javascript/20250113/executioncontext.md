

### 실행 컨택스트 

> 자바스크립트의 실행 컨텍스는 식별자를 좀더 효율적으로 관리해서 퍼포먼스를 끌어 올렸다고 보면 된다.

## 자바스크립트의 엔진
> 우리가 사용하는 자바스크립트 엔진은 스크립트를 실행하면
> 콜 스텍에 전역 실행 컨텍스트를 생성하고 이 컨택스트의 안에는 `레코드` 와 `아우터` 가 있다.

> 전역 스코프에 있는 변수들 기록 하는 `레코드` 그거 가져올때 사용하는 친구 아우터
실행 컨택스트 안에는 레코드와 아우터가 존재한다
(함수의 실행 순서를 몰라 쉽게 이해할수 있음 함수의 실행순거)

## 자바스크립트의 호이스팅

```js
console.log(myValue); 에러가 발생할까?

var myValue;

// 자비스크립트는 변수를 먼저 읽어서 기록을 하고 실행컨텍스트에 미리 저장을 한다
?/ 이 저장하는 공간은 레코드라는 영역
// 환경 레코드 == 식별자와 식별자의 값을  기록하는 객체

// 초기에 자바스크립트 실행하면 전체를 한몪으로 실행을 하고 전역 컨텍스트를 생성한다
// 이때  전역 곡산에 있는 변수 등을 모구다 레코드에 기록한다 . 이때 `생겅 단뎨` ` 싱행 단계`

// 이때 var 는 값을 undefined 로 초기화 해준다 . let 은 빈값으로 초기화한다. const도

// 이후 선언문 이외의 코드를 실행하는 단계는 실핸 단계
// 이때 이후에 업데이트할 내영 여기서 일어난다

// let 의 값 초기화  이전에 식별자르 참조할수 럾는 영역을 개발자가 만든것

// ES6 S는 목적성을 많이 추구한 구문의 내영이 많이 추가되었는데
// 선언전에 변수를 호출하는것은 일반적인 프로그래밍 언어와 다른 내용이기떄문에 일반적인 프로그래밍 언어처럼 추구하자


```

## 자바스크립트의 스코프
```JS
전역 스코프
let myValue = 1;

// 함수
function fo(){
    //지역 스코프
    let myValue = 2;
    console.log(myValue);
}

fo();  // 함수를 선언한후에 호출합니다

// 함수도 값이다.  값

const a = function fo() {

}
a();
// 이렇게 할당이 가능하가.


// 함수 안에서 함수가 호출되면

function foo() {
    
    foo2();
    let myValue = 2;
}

function foo2() {
    foo3();
}

function foo3() {
    console.log(myValue);
}

foo();

stack and queue   stack process from top or last
                queue process from first bottom

```